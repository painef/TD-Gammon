}
}
}
}
boards
}
# to help the humans: given before/after board configurations, produce
# human readable description of the implied move
# will fail if the two board configurations are not connected by a single roll of the dice
describe.move=function(roll,before.board,after.board){
require(gtools)
diff=after.board-before.board
#print(diff)
blots=c()
if(diff[b.bar] != 0){  # move hit 1 or more blots
blots=which(before.board == -1 & after.board >= 0)
#print(paste("blots=",paste(blots,collapse=",")))
for(b in blots) before.board[b]=0 # was -1
after.board[b.bar]=before.board[b.bar]
diff=after.board-before.board
}
# diff can be >1
from=c(which(diff<0),which(diff< -1),which(diff< -2),which(diff< -3))
to=c(which(diff>0),which(diff>1),which(diff>2),which(diff>3))
if(length(from)==0){
return("no move")
}
if(length(roll)==2){
roll=c(roll,sum(roll))
}else{
roll=c(roll,2*roll[1],3*roll[1],4*roll[1])
}
if(any(to==w.off)) roll=c(roll,from-w.off)  # append fake roll(s) to allow bearing off
if(length(from)<=2){
d=from-to
if(!all(d %in% roll)) to=rev(to)
if(!all((from-to) %in% roll)) {
print(paste("roll=",paste(roll)))
print.board(before.board)
print.board(after.board)
print(from)
print(to)
print(paste("diff=",paste(from-to,collapse=",")))
stop("should give roll values")
}
}else{
# will need to look at permutations
n=length(from)
map=permutations(n,n,1:n)
for(row in 1:nrow(map)){
p=map[row,]
d=from-to[p]
if(all(d %in% roll)){
to=to[p];
break;
}
}
if(!all((from-to) %in% roll)) {
print(paste("roll=",paste(roll)))
print.board(before.board)
print.board(after.board)
print(from)
print(to)
print(paste("diff=",paste(from-to,collapse=",")))
stop("should give roll values")
}
}
desc=""
for(i in 1:length(from)) desc=paste0(desc,"(",from[i],",",to[i],")")
for(b in blots) desc=paste0(desc,"(",b,",",b.bar,")")
return(desc)
}
# should produce a valid board configuration on each call
random.board=function(){
board=rep(0,28)
points=sample.int(26,15,replace=TRUE)
for(p in points) board[p]=board[p]+1
xboard=board
xboard[c(25,26)]=1
points=sample(which(xboard==0),15,replace=TRUE)
for(p in points) board[p]=board[p]-1
#print(sum(board))
board
}
if(FALSE){
# compute time to play N games
start.time=Sys.time()
for(i in 1:10000) play.game(verbose=FALSE)
end.time=Sys.time()
end.time-start.time
verbose=TRUE
history=play.game(verbose)
}
if(FALSE){
roll.dice=roll.dice.cl()
verbose=TRUE
board=random.board()
roll=roll.dice()
#roll=c(1,1,1,1)
moves=find.all.possible.moves(board,roll)
duplicated(moves)
print(length(moves))
for(i in seq_along(moves)) {
print(paste(paste0("[",i,"]"),paste(roll,collapse=","),describe.move(roll,board,moves[[i]])))
print.board(board)
print.board(moves[[i]])
#print(describe.move(roll,board,moves[[i]]))
}
moves=unique(moves)
print(length(moves))
for(i in seq_along(moves)) {
print(paste(paste0("[",i,"]"),paste(roll,collapse=","),describe.move(roll,board,moves[[i]])))
print.board(board)
print.board(moves[[i]])
#print(describe.move(roll,board,moves[[i]]))
}
}
if(FALSE){
board=init.board()
rolls=as.matrix(expand.grid(1:6,1:6))
boards=list()
for(i in 1:nrow(rolls)) {
roll=c(rolls[i,1],rolls[i,2])
if(roll[1]==roll[2]) roll=c(roll,roll)
boards=c(boards,find.all.possible.moves(board,roll))
}
print(length(boards))
boards=unique(boards)
print(length(boards))
}
random.board()
print.board(random.board())
install.packages("rJava",,"http://rforge.net")
install.packages("rJava")
R CMD javareconf
install.packages("rJava")
tt <- tktoplevel()
bb<-1
img <-tkrplot(tt, function() plot(1:20,(1:20)^bb))
f<-function(...) {
b <- as.numeric(tclvalue("bb"))
if (b != bb) {
bb <<- b
tkrreplot(img)
}
}
s <- tkscale(tt, command=f, from=0.05, to=2.00, variable="bb",
showvalue=FALSE, resolution=0.05, orient="horiz")
tkpack(img,s)
install.packages("rJava")
shiny::runApp('Documents/GitHub/TD-Gammon/backgammon_shiny')
60/7.0
shiny::runApp('Documents/GitHub/TD-Gammon/backgammon_shiny')
runApp()
setwd("~/Documents/GitHub/TD-Gammon/backgammon_shiny")
runApp()
runApp()
min(1,4)
x = 1
x +=1
features <- function(board, player){
features = c()
for (p in 1:2){
for (col in 1:24){
feats = c(0,0,0,0,0,0)
if (board[col] > 0 && p == 1){
# player 1 has pieces
for ( i in  1:board[col]){
feats[min(i,5)] = feats[min(i,5)] + 1
}
features = c(features, feats)
}
else if (board[col] < 0 && p == 2){
for ( i in  1:abs(board[col])){
#python is 0 indexed!
# not sure why first term is always zero
feats[min(1+i,6)] = feats[min(1+i,6)] + 1
}
features = c(features, feats)
}
else{
features = c(features, c(0,0,0,0,0,0))
}
}
# 25=white bar, 26=white off, 27=black off, 28=black bar
# bar and off board
if (p == 1){
features = c(features, board[25]/2.0, board[26]/15)
}
if (p == 2){
features = c(features, board[28]/2.0, board[27]/15)
}
}
# which player player
if (player){
features = c(features, 0, 1)
}
else {
features = c(features, 1, 0)
}
}
features <- function(board, player){
features = c()
for (p in 1:2){
for (col in 1:24){
feats = c(0,0,0,0,0,0)
if (board[col] > 0 && p == 1){
# player 1 has pieces
for ( i in  1:board[col]){
feats[min(i,5)] = feats[min(i,5)] + 1
}
features = c(features, feats)
}
else if (board[col] < 0 && p == 2){
for ( i in  1:abs(board[col])){
#python is 0 indexed!
# not sure why first term is always zero
feats[min(1+i,6)] = feats[min(1+i,6)] + 1
}
features = c(features, feats)
}
else{
features = c(features, c(0,0,0,0,0,0))
}
}
# 25=white bar, 26=white off, 27=black off, 28=black bar
# bar and off board
if (p == 1){
features = c(features, board[25]/2.0, board[26]/15)
}
if (p == 2){
features = c(features, board[28]/2.0, board[27]/15)
}
}
# which player player
if (player){
features = c(features, 0, 1)
}
else {
features = c(features, 1, 0)
}
return(features())
}
findFeat <- function(board, player){
features = c()
for (p in 1:2){
for (col in 1:24){
feats = c(0,0,0,0,0,0)
if (board[col] > 0 && p == 1){
# player 1 has pieces
for ( i in  1:board[col]){
feats[min(i,5)] = feats[min(i,5)] + 1
}
features = c(features, feats)
}
else if (board[col] < 0 && p == 2){
for ( i in  1:abs(board[col])){
#python is 0 indexed!
# not sure why first term is always zero
feats[min(1+i,6)] = feats[min(1+i,6)] + 1
}
features = c(features, feats)
}
else{
features = c(features, c(0,0,0,0,0,0))
}
}
# 25=white bar, 26=white off, 27=black off, 28=black bar
# bar and off board
if (p == 1){
features = c(features, board[25]/2.0, board[26]/15)
}
if (p == 2){
features = c(features, board[28]/2.0, board[27]/15)
}
}
# which player player
if (player){
features = c(features, 0, 1)
}
else {
features = c(features, 1, 0)
}
return(features())
}
findFeat(random.board(), T)
random.board()
x = random.board()
findFeat(x, T)
x[1]
findFeat <- function(boardF, player){
features = c()
for (p in 1:2){
for (col in 1:24){
feats = c(0,0,0,0,0,0)
if (boardF[col] > 0 && p == 1){
# player 1 has pieces
for ( i in  1:boardF[col]){
feats[min(1+i,6)] = feats[min(1+i,6)] + 1
}
features = c(features, feats)
}
else if (boardF[col] < 0 && p == 2){
for ( i in  1:abs(boardF[col])){
#python is 0 indexed!
# not sure why first term is always zero
feats[min(1+i,6)] = feats[min(1+i,6)] + 1
}
features = c(features, feats)
}
else{
features = c(features, c(0,0,0,0,0,0))
}
}
# 25=white bar, 26=white off, 27=black off, 28=black bar
# bar and off board
if (p == 1){
features = c(features, boardF[25]/2.0, boardF[26]/15)
}
if (p == 2){
features = c(features, boardF[28]/2.0, boardF[27]/15)
}
}
# which player player
if (player){
features = c(features, 0, 1)
}
else {
features = c(features, 1, 0)
}
return(features)
}
findFeat(x,T)
len(findFeat(x,T))
length(findFeat(x,T))
w = readBin('weights0.bin', "numeric")
w
readBin('weights0.bin')
w = readBin('weights0.bin', what="numeric")
w = readBin('weights0.bin', what="raw")
raw
w
w = readBin('weights0.bin', what="double")
w = readBin('weights0.bin', what="double")
install.packages('reticulate')
source_python("wimport.py")
require(reticulate)
source_python("wimport.py")
source_python("wimport.py")
pickle_data <- read_file("weights0.bin")
pickle_data
weights <- read_file("weights0.bin")
w <- read_file("weights0.bin")
#w = readBin('weights0.bin', what="double")
w1 = w[1]
w1
#w = readBin('weights0.bin', what="double")
w1 = w[[1]]
w1
?shape
?size
dim(w[1])
dim([[1]])
dim(w[[1]])
dim(w[[2]])
w2 = w[[3]]
dim(w2)
# get features
feat = findFeat(boardF, player)
feat = findFeat(x, T)
dim(feat)
feat
len(feat)
length(feat)
nrow(b1)
#w = readBin('weights0.bin', what="double")
w1 = w[[1]]  # 50 by 294
b1 = w[[2]]  # 1  by 50
w2 = w[[3]]  # 50 by 1
b2 = w[[4]]  # 1 by 1
nrow(b1)
# get features
feat = array(findFeat(boardF, player))
feat = array(feat)
dim(feat)
feat = array(featm dim = c(294,1))
feat = array(feat, dim = c(294,1))
# z = 50x1 + 50x294*294x1
z = t(b1) + w1 %*% feat
# h = 1 + 1x50 * 50x1
h = b2 + t(w2) %*% sigmoid(z)
sigmoid = function(x) 1 / (1 + exp(-x))
# h = 1 + 1x50 * 50x1
h = b2 + t(w2) %*% sigmoid(z)
sigmoid(h)
roll <<- roll.dice()
board <<-init.black() + init.white()
moves = find.all.possible.moves(board,roll)
length(moves)
moves[1]
moves[[1]]
runApp()
runApp()
bboard
board
length(board)
init.black() + init.white()
length(init.black() + init.white())
ai_move <- function(boardF, roll, player)
{}
runApp()
board
roll
ai_move(board,roll,playerB)
require(reticulate)
source_python("wimport.py")
w <<- read_file("weights0.bin")
find.all.possible.moves(board, roll)
x = find.all.possible.moves(board, roll)
is.null(x)
is.empty(x)
empty(x)
length(list())
runApp()
runApp()
runApp()
runApp()
runApp()
possible()
runApp()
runApp()
runApp()
runApp()
runApp()
possible()
input$AIturn != valueAIturn
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
py_install(c('reticulate'))
py_install(c('reticulate'))
py_install('reticulate')
runApp()
py_install(c('pickle'))
py_install(c('pickle'))
runApp()
py_install(c('pickle'))
use_virtualenv("~")
py_install(c('pickle'))
py_config()
runApp()
library(reticulate)
import("pickle")
reticulate::py_config()
setwd("~/Documents/GitHub/TD-Gammon/backgammon_shiny")
use_virtualenv('~/Documents/GitHub/TD-Gammon/backgammon_shiny', required = TRUE)
#features = extractFeatures((game,game.opponent(self.player)))
#hiddenAct = 1/(1+np.exp(-(self.w1.dot(features)+self.b1)))
#v = 1/(1+np.exp(-(self.w2.dot(hiddenAct)+self.b2)))
#py_install(c('pickle'))
require(reticulate)
use_virtualenv('./env', required = TRUE)
runApp()
runApp()
#features = extractFeatures((game,game.opponent(self.player)))
#hiddenAct = 1/(1+np.exp(-(self.w1.dot(features)+self.b1)))
#v = 1/(1+np.exp(-(self.w2.dot(hiddenAct)+self.b2)))
#py_install(c('pickle'))
Sys.setenv(RETICULATE_PYTHON = './env/bin/python')
#features = extractFeatures((game,game.opponent(self.player)))
#hiddenAct = 1/(1+np.exp(-(self.w1.dot(features)+self.b1)))
#v = 1/(1+np.exp(-(self.w2.dot(hiddenAct)+self.b2)))
#py_install(c('pickle'))
Sys.setenv(RETICULATE_PYTHON = './env/bin/python')
require(reticulate)
use_virtualenv('./env', required = TRUE)
#features = extractFeatures((game,game.opponent(self.player)))
#hiddenAct = 1/(1+np.exp(-(self.w1.dot(features)+self.b1)))
#v = 1/(1+np.exp(-(self.w2.dot(hiddenAct)+self.b2)))
#py_install(c('pickle'))
Sys.setenv(RETICULATE_PYTHON = './env/bin/python')
require(reticulate)
use_virtualenv('./env', required = TRUE)
source_python("wimport.py")
w <<- read_file("weights0.bin")
source_python("wimport.py")
w <<- read_file("weights0.bin")
shiny::runApp()
#features = extractFeatures((game,game.opponent(self.player)))
#hiddenAct = 1/(1+np.exp(-(self.w1.dot(features)+self.b1)))
#v = 1/(1+np.exp(-(self.w2.dot(hiddenAct)+self.b2)))
#py_install(c('pickle'))
Sys.setenv(RETICULATE_PYTHON = './env/bin/python')
require(reticulate)
use_virtualenv('./env', required = TRUE)
source_python("wimport.py")
#features = extractFeatures((game,game.opponent(self.player)))
#hiddenAct = 1/(1+np.exp(-(self.w1.dot(features)+self.b1)))
#v = 1/(1+np.exp(-(self.w2.dot(hiddenAct)+self.b2)))
py_install(c('pickle'))
w <- read_file("weights0.bin")
read_file("weights0.bin")
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
