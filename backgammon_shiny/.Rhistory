n=length(possible.moves)
if(verbose)print(paste("found",n,"unique possible moves"))
old.board=board
i=0
if(n>0){
i=sample(n,1)
board=possible.moves[[i]]
#if(verbose)print.board(board)
}else{
if(verbose)print(paste(player,"unable to play"))
}
play=describe.move(roll,old.board,board)
history[[length(history)+1]]=list(player=player,roll=roll,play=play,board=old.board)
#print(is.list(board))
#print(str(board))
#print(length(board))
#print(board)
if(verbose)print.board(board)
if(!check.board(board)!=0)stop("bad board")
}
if(player==-1)board=flip.board(board)
history[[length(history)+1]]=list(player=player,roll=NA,board=board)
#print(paste("gave.over=",player,game.over(board)))
#print.board(board)
list(player=player,turns=turns,history=history)
}
# returns a list of board configurations that can result from a roll
# note that the order of the dice can make a difference, so both orders are used
# assumes roll has 2 different integers or 4 identical integers
# WATCH OUT - uses global verbose setting
find.all.possible.moves=function(board,roll){
one.move.boards=vector("list",2)
two.move.boards=list()
#print("start board")
#print.board(board)
if(roll[1]!=roll[2]){
for(i in 1L:2L){
one.move.boards[[i]]=make.single.move(board,roll[i])
if(length(one.move.boards[[i]])>0){
for(j in seq_along(one.move.boards[[i]])){
two.move.boards=c(two.move.boards,make.single.move(one.move.boards[[i]][[j]],roll[3L-i]))
}
if(verbose) print(paste("i=",i,length(unique(two.move.boards))))
}
}
if(length(two.move.boards)>0){
return(two.move.boards)
}
if(verbose)print("returning one.move.boards")
return(c(one.move.boards[[1]],one.move.boards[[2]]))
}else{
start.boards=list(board)
end.boards=vector("list",4)
for(i in 1:4){
#print(paste("length(start.boards)=",length(start.boards)))
for(j in seq_along(start.boards)){
end.boards[[i]]=c(end.boards[[i]],make.single.move(start.boards[[j]],roll[i]))
}
if(is.null(end.boards[[i]]) || length(end.boards[[i]])==0) break;
end.boards[[i]]=unique(end.boards[[i]])
start.boards=end.boards[[i]]
}
if(i>1){
return(end.boards[[i]])
}
return(list())
}
}
# returns list of new board configurations that can result from moving according to just one die
# WATCH OUT - uses global verbose setting
make.single.move=function(board,roll){
boards=list()
# if bar is not empty, must re-enter all before moving board pieces
if(board[w.bar]>0){
if(verbose)print("bar move")
q=w.bar-roll
if(board[q]>-2) {
new.board=board
new.board[w.bar]=new.board[w.bar]-1
if(new.board[q]==-1) {
new.board[q]=0
new.board[b.bar]=new.board[b.bar]-1
}
new.board[q]=new.board[q]+1
boards[[length(boards)+1]]=new.board
}
}else{
wp=white.points(board)
if(!can.bear.off(board)) {  # if all points are not <= 6, then can't bearoff yet
for(p in wp) {
if(p > roll) {
q=p-roll
if(board[q]>-2){
new.board=board
#print(paste("move",p,"to",q))
#print.board(new.board)
new.board[p]=new.board[p]-1
if(new.board[q]==-1) {
new.board[q]=0
new.board[b.bar]=new.board[b.bar]-1
}
new.board[q]=new.board[q]+1
boards[[length(boards)+1]]=new.board
#print.board(new.board)
}
}
}
}else{
if(verbose)print("can bear off")
for(p in wp) {
q=p-roll
if(q>=1){  # on-board move
if(board[q]>-2){
new.board=board
new.board[p]=new.board[p]-1
if(new.board[q]==-1) {
new.board[q]=0
new.board[b.bar]=new.board[b.bar]-1
}
new.board[q]=new.board[q]+1
boards[[length(boards)+1]]=new.board
}
}else{
if(verbose)print("bear off")
new.board=board
new.board[p]=new.board[p]-1
new.board[w.off]=new.board[w.off]+1
boards[[length(boards)+1]]=new.board
}
}
}
}
boards
}
# to help the humans: given before/after board configurations, produce
# human readable description of the implied move
# will fail if the two board configurations are not connected by a single roll of the dice
describe.move=function(roll,before.board,after.board){
require(gtools)
diff=after.board-before.board
#print(diff)
blots=c()
if(diff[b.bar] != 0){  # move hit 1 or more blots
blots=which(before.board == -1 & after.board >= 0)
#print(paste("blots=",paste(blots,collapse=",")))
for(b in blots) before.board[b]=0 # was -1
after.board[b.bar]=before.board[b.bar]
diff=after.board-before.board
}
# diff can be >1
from=c(which(diff<0),which(diff< -1),which(diff< -2),which(diff< -3))
to=c(which(diff>0),which(diff>1),which(diff>2),which(diff>3))
if(length(from)==0){
return("no move")
}
if(length(roll)==2){
roll=c(roll,sum(roll))
}else{
roll=c(roll,2*roll[1],3*roll[1],4*roll[1])
}
if(any(to==w.off)) roll=c(roll,from-w.off)  # append fake roll(s) to allow bearing off
if(length(from)<=2){
d=from-to
if(!all(d %in% roll)) to=rev(to)
if(!all((from-to) %in% roll)) {
print(paste("roll=",paste(roll)))
print.board(before.board)
print.board(after.board)
print(from)
print(to)
print(paste("diff=",paste(from-to,collapse=",")))
stop("should give roll values")
}
}else{
# will need to look at permutations
n=length(from)
map=permutations(n,n,1:n)
for(row in 1:nrow(map)){
p=map[row,]
d=from-to[p]
if(all(d %in% roll)){
to=to[p];
break;
}
}
if(!all((from-to) %in% roll)) {
print(paste("roll=",paste(roll)))
print.board(before.board)
print.board(after.board)
print(from)
print(to)
print(paste("diff=",paste(from-to,collapse=",")))
stop("should give roll values")
}
}
desc=""
for(i in 1:length(from)) desc=paste0(desc,"(",from[i],",",to[i],")")
for(b in blots) desc=paste0(desc,"(",b,",",b.bar,")")
return(desc)
}
# should produce a valid board configuration on each call
random.board=function(){
board=rep(0,28)
points=sample.int(26,15,replace=TRUE)
for(p in points) board[p]=board[p]+1
xboard=board
xboard[c(25,26)]=1
points=sample(which(xboard==0),15,replace=TRUE)
for(p in points) board[p]=board[p]-1
#print(sum(board))
board
}
if(FALSE){
# compute time to play N games
start.time=Sys.time()
for(i in 1:10000) play.game(verbose=FALSE)
end.time=Sys.time()
end.time-start.time
verbose=TRUE
history=play.game(verbose)
}
if(FALSE){
roll.dice=roll.dice.cl()
verbose=TRUE
board=random.board()
roll=roll.dice()
#roll=c(1,1,1,1)
moves=find.all.possible.moves(board,roll)
duplicated(moves)
print(length(moves))
for(i in seq_along(moves)) {
print(paste(paste0("[",i,"]"),paste(roll,collapse=","),describe.move(roll,board,moves[[i]])))
print.board(board)
print.board(moves[[i]])
#print(describe.move(roll,board,moves[[i]]))
}
moves=unique(moves)
print(length(moves))
for(i in seq_along(moves)) {
print(paste(paste0("[",i,"]"),paste(roll,collapse=","),describe.move(roll,board,moves[[i]])))
print.board(board)
print.board(moves[[i]])
#print(describe.move(roll,board,moves[[i]]))
}
}
if(FALSE){
board=init.board()
rolls=as.matrix(expand.grid(1:6,1:6))
boards=list()
for(i in 1:nrow(rolls)) {
roll=c(rolls[i,1],rolls[i,2])
if(roll[1]==roll[2]) roll=c(roll,roll)
boards=c(boards,find.all.possible.moves(board,roll))
}
print(length(boards))
boards=unique(boards)
print(length(boards))
}
random.board()
print.board(random.board())
install.packages("rJava",,"http://rforge.net")
install.packages("rJava")
R CMD javareconf
install.packages("rJava")
tt <- tktoplevel()
bb<-1
img <-tkrplot(tt, function() plot(1:20,(1:20)^bb))
f<-function(...) {
b <- as.numeric(tclvalue("bb"))
if (b != bb) {
bb <<- b
tkrreplot(img)
}
}
s <- tkscale(tt, command=f, from=0.05, to=2.00, variable="bb",
showvalue=FALSE, resolution=0.05, orient="horiz")
tkpack(img,s)
install.packages("rJava")
shiny::runApp('Documents/GitHub/TD-Gammon/backgammon_shiny')
shiny::runApp('Documents/GitHub/TD-Gammon/backgammon_shiny')
shiny::runApp('Documents/GitHub/TD-Gammon/backgammon_shiny')
runApp()
runApp('Documents/GitHub/TD-Gammon/backgammon_shiny')
w1.in <-read.csv2("w1.csv")
getwd()
setwd("~/Documents/GitHub/TD-Gammon/backgammon_shiny")
w1.in <-read.csv2("w1.csv")
w1
w1.in
w1.in <-read.csv("w1.csv")
?read.csv
w1.in <-read.csv("w1.csv", header = F)
w1.in <- read.csv("w1.csv", header = F)
b1.in <- read.csv("b1.csv", header = F)
w2.in <- read.csv("w2.csv", header = F)
b2.in <- read.csv("b2.csv", header = F)
dim(w1.in)
dim(b1)
dim(b1.in)
dim(w2.in)
dim(b2.in)
runApp()
runApp()
shiny::runApp()
runApp()
?cdf
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
df_board.x = NULL
df_board.y = NULL
# Points on main board
x.points = seq(3,47, by=4)
for (i in x.points){
df_board.x = c(df_board.x, rep(i, times = 20))
df_board.y = c(df_board.y, seq(5,7,by=.25), seq(1,3,by=.25))
}
# Points for bearing off
df_board.x = c(df_board.x, rep(52, times = 15), rep(55, times = 15))
df_board.y = c(df_board.y, seq(1.4,7,by=.4), seq(1.4,7,by=.4))
df_board.x = c(df_board.x, 17.5, 20, 22.5, 17.5, 20, 22.5,
27.5, 30, 32.5, 27.5, 30, 32.5 )
df_board.y = c(df_board.y, 3.75, 3.75, 3.75, 4.25, 4.25, 4.25,
3.75, 3.75, 3.75, 4.25, 4.25, 4.25)
df_board = data.frame(cbind(df_board.x,df_board.y))
colnames(df_board)<- c("x", "y")
length(df_board)
length(df_board.x)
length(df_board.y)
df_board.x = NULL
df_board.y = NULL
# Points on main board
x.points = seq(3,47, by=4)
for (i in x.points){
df_board.x = c(df_board.x, rep(i, times = 10))
df_board.y = c(df_board.y, seq(5,7,by=.5), seq(1,3,by=.5))
}
# Points for bearing off
df_board.x = c(df_board.x, rep(52, times = 15), rep(55, times = 15))
df_board.y = c(df_board.y, seq(1.4,7,by=.4), seq(1.4,7,by=.4))
df_board.x = c(df_board.x, 17.5, 20, 22.5, 17.5, 20, 22.5,
27.5, 30, 32.5, 27.5, 30, 32.5 )
df_board.y = c(df_board.y, 3.75, 3.75, 3.75, 4.25, 4.25, 4.25,
3.75, 3.75, 3.75, 4.25, 4.25, 4.25)
df_board.x = NULL
df_board.y = NULL
# Points on main board
x.points = seq(3,47, by=4)
for (i in x.points){
df_board.x = c(df_board.x, rep(i, times = 20))
df_board.y = c(df_board.y, seq(5,7,by=.25), seq(1,3,by=.25))
}
seq(5,7,by=.25)
length()
length((seq(5,7,by=.25), seq(1,3,by=.25)))
length(c(seq(5,7,by=.25), seq(1,3,by=.25)))
length(c(seq(5,7,by=.5), seq(1,3,by=.5)))
length(c(seq(5,7,by=.125), seq(1,3,by=.125)))
# Points for bearing off
df_board.x = c(df_board.x, rep(52, times = 15), rep(55, times = 15))
runApp()
lenght(seq(4.5,7,by=.125), seq(1,3.5,by=.125))
length(seq(4.5,7,by=.125), seq(1,3.5,by=.125))
length(seq(4.5,7,by=.125), seq(1,3.5,by=.125))
length(c(seq(4.5,7,by=.125), seq(1,3.5,by=.125)))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
possible()
runApp()
runApp()
5*.5
runApp()
runApp()
runApp()
points(x = loc, y = 7.25-j*.3, pch = 19, cex = 3, col = colP)
runApp()
7*.3
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
length(c(seq(4,7,by=.125), seq(1,3,by=.125)))
runApp()
runApp()
runApp()
runApp()
runApp()
board_update <- function(selected_points) {
x.move = selected_points$x
y.move = selected_points$y
print("x.move  ||  y.move")
print(x.move)
print(y.move)
# TO DO check choice is valid
#valid = check_choice(selected_points)
valid = !empty(selected_points)
if(valid && !inactive){
if(x.move > 50 && x.move <53){
if(check_off()){
board[26] <<- board[26] + 1
move <<- !move
}
return(board)
}
else if (x.move >53 && x.move < 56){
if(check_off()){
move <<- !move
board[27] <<- board[27] + 1
}
return(board)
}
# 25=white bar, 26=white off, 27=black off, 28=black bar
else if(y.move > 3.5 && y.move <4.5 && x.move <25){
print("white bar")
if (move){
board[25] <<- board[25] - 1
move <<- !move
return(board)
}
else {
board[25] <<- board[25] + 1
move <<- !move
return(board)
}
}
else if (y.move >3.5 && y.move < 4.5 && x.move >25){
print("black bar")
if(move){
move <<- !move
board[28] <<- board[28] - 1
return(board)
}
else{
move <<- !move
board[28] <<- board[28] + 1
return(board)
}
}
else if(x.move < 50){
board_move(selected_points)
}
}
else {
return(board)
}
}
runApp()
runApp()
make.single.move(board, roll)
make.single.move(board, 1)
make.single.move(board, 4)
check_move
runApp()
runApp()
roll
5 %in% roll
3 %in% roll
3 %in% NULL
?remove
rm(3, c(3,4))
?drop
test <- c(2,3,4)
test = test[test!=3]
test
runApp()
runApp()
runApp()
runApp()
runApp()
test = c(1,2,3,3)
match(test,3)
test[-match(3, test)]
test = c(3,3,3,3)
test[-match(3, test)]
runApp()
runApp()
runApp()
